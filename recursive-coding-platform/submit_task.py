import sys
import time
import uuid
import os
import asyncio
import json
from datetime import datetime
from dht_backend import create_dht

BOOTSTRAP_FILE = "hivemind_bootstrap.json"

def _load_bootstrap_peers() -> list:
    try:
        if os.path.exists(BOOTSTRAP_FILE):
            with open(BOOTSTRAP_FILE, "r", encoding="utf-8") as f:
                data = json.load(f)
            peers = data.get("peers") or []
            return peers if isinstance(peers, list) else []
    except Exception:
        return []
    return []

async def submit_task(description: str):
    """Submit a coding task to the network"""
    
    print("=" * 60)
    print("SUBMITTING TASK TO NETWORK")
    print("=" * 60)
    print(f"Task: {description}")
    print()
    
    # Connect to DHT (hivemind on Linux/WSL, SharedState on Windows)
    print("Connecting to network...")
    peers = _load_bootstrap_peers()
    dht = create_dht(initial_peers=peers)
    
    # Wait a moment for nodes to be ready
    await asyncio.sleep(2)
    
    backend_type = getattr(dht, "backend_type", None)
    
    # Find available nodes (SharedState only; hivemind can't list keys)
    nodes = {}
    print("Discovering nodes...")
    if backend_type != "hivemind":
        nodes = dht.get_all_nodes()
        if not nodes:
            print("[WARNING] No nodes found in network. Make sure network.py is running!")
            print("Waiting for nodes to appear...")
            for _ in range(10):
                await asyncio.sleep(1)
                nodes = dht.get_all_nodes()
                if nodes:
                    break
    
    # Always use broadcast for better task distribution
    # Nodes will pick up broadcast tasks when they're available
    target_node = "broadcast"
    
    if nodes:
        print(f"Found {len(nodes)} node(s) in network")
        print("Using broadcast mode - any available node will pick up the task")
    else:
        print("[WARNING] No nodes found, but will still submit task (nodes may appear later)")
    
    # Generate task ID
    task_id = str(uuid.uuid4())[:8]
    
    # Create task
    task = {
        "id": task_id,
        "description": description,
        "mission": {
            "goal": description
        },
        "context_chain": [],
        "contract": {},
        "tests": []
    }
    
    # Submit to shared state / DHT as broadcast task
    task_key = f"task:broadcast:{task_id}"
    
    print(f"Task ID: {task_id}")
    print("Submitting to network...")
    
    try:
        # Store the task payload itself
        await dht.astore(
            key=task_key,
            value=task,
            expiration_time=600
        )
        
        # If we're using hivemind backend, also push the task_id onto a simple
        # queue stored at "task_queue" so workers can discover tasks without
        # needing to list all keys (which hivemind does not support).
        if backend_type == "hivemind":
            queue = await dht.aget("task_queue") or []
            if not isinstance(queue, list):
                queue = []
            queue.append(task_id)
            # Keep the queue around for a while; it will be refreshed as tasks arrive
            await dht.astore("task_queue", queue, expiration_time=3600)
        
        print("[OK] Task submitted successfully")
        print(f"Task stored with key: {task_key}")
        print()
        print("Waiting for result...")
        print("(This may take 1-5 minutes for complex tasks)")
        print()
        
        # Wait for result (no timeout - wait indefinitely)
        start_time = time.time()
        
        print("Waiting indefinitely for result (no timeout)...")
        
        while True:
            result = await dht.aget(f"result:{task_id}")
            
            if result:
                print("=" * 60)
                print("RESULT RECEIVED")
                print("=" * 60)
                
                if result.get('success'):
                    code = result.get('code', 'No code generated')
                    node_id = result.get('node', 'unknown')
                    
                    print(f"Generated by node: {node_id}")
                    print()
                    print("CODE:")
                    print("-" * 60)
                    print(code)
                    print("-" * 60)
                    
                    # Save code to file
                    output_dir = "output"
                    if not os.path.exists(output_dir):
                        os.makedirs(output_dir)
                    
                    # Determine file extension based on task description
                    ext = ".jsx"  # Default for React
                    desc_lower = description.lower()
                    if "python" in desc_lower or ".py" in desc_lower:
                        ext = ".py"
                    elif "javascript" in desc_lower or ".js" in desc_lower:
                        ext = ".js"
                    elif "typescript" in desc_lower or ".ts" in desc_lower:
                        ext = ".ts"
                    elif "react" in desc_lower or "component" in desc_lower:
                        ext = ".jsx"
                    elif "html" in desc_lower:
                        ext = ".html"
                    elif "css" in desc_lower:
                        ext = ".css"
                    
                    # Create filename with timestamp and task ID
                    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                    filename = f"{output_dir}/task_{task_id}_{timestamp}{ext}"
                    
                    try:
                        with open(filename, 'w', encoding='utf-8') as f:
                            f.write(f"// Task: {description}\n")
                            f.write(f"// Generated by node: {node_id}\n")
                            f.write(f"// Task ID: {task_id}\n")
                            f.write(f"// Generated at: {datetime.now().isoformat()}\n")
                            if result.get('integrated_from'):
                                f.write(f"// Integrated from subtasks: {result['integrated_from']}\n")
                            f.write("\n")
                            f.write(code)
                        
                        print()
                        print(f"[OK] Code saved to: {filename}")
                        
                    except Exception as e:
                        print()
                        print(f"[WARNING] Could not save code to file: {e}")
                    
                    if result.get('integrated_from'):
                        print()
                        print(f"Integrated from subtasks: {result['integrated_from']}")
                else:
                    print(f"[ERROR] Task failed: {result.get('error', 'Unknown error')}")
                
                return
            
            # Show progress
            elapsed = int(time.time() - start_time)
            if elapsed % 10 == 0 and elapsed > 0:
                print(f"  Still waiting... ({elapsed}s elapsed)")
                # Check if task is still in queue
                if elapsed % 30 == 0:
                    task_check = await dht.aget(task_key)
                    if task_check:
                        print(f"  [DEBUG] Task still in queue, waiting for node to pick it up...")
                    else:
                        print(f"  [DEBUG] Task was picked up, waiting for result...")
            
            await asyncio.sleep(2)
        
        # This should never be reached since we removed timeout, but keep for safety
        print(f"[ERROR] Unexpected exit from wait loop")
        print(f"Task key was: {task_key}")
        print("Check the network terminal for any error messages")
        
    except Exception as e:
        print(f"[ERROR] Error: {e}")

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: python submit_task.py \"<your coding task>\"")
        print()
        print("Examples:")
        print('  python submit_task.py "Create a function to calculate fibonacci numbers"')
        print('  python submit_task.py "Build a React component for a todo list"')
        print('  python submit_task.py "Write a Python function to sort a list of dictionaries"')
        sys.exit(1)
    
    task_description = sys.argv[1]
    asyncio.run(submit_task(task_description))
